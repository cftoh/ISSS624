---
title: "Hands-on Exercise 2: Choropleth Mapping with R"
date: "17 November 2023"
date-modified:  "last-modified"
format: html
execute:
  echo: true
  eval: true
  warning:  false
editor: visual
---

This will be built upon the basic of R Programming, after setup

\*\*useful to just type "/" then it will allow easier insert of code chunks (rather than having to type \`\`\`{r} all the time

```{r}

```

Key R Package used is [**tmap**](https://cran.r-project.org/web/packages/tmap/) package in R, but the following will be used to:

-   [**readr**](https://readr.tidyverse.org/) for importing delimited text file,

-   [**tidyr**](https://tidyr.tidyverse.org/) for tidying data,

-   [**dplyr**](https://dplyr.tidyverse.org/) for wrangling data and

-   [**sf**](https://cran.r-project.org/web/packages/sf/) for handling geospatial data.

**readr**, **tidyr** and **dplyr** are part of **tidyverse** package.

To first install the package:

```{r}
pacman::p_load(sf, tmap, tidyverse)
```

## Import Data into R

The Data set used to create **choropleth map:**

1.  Master Plan 2014 Subzone Boundry (Web)

    ```{r}
    mpsz <- st_read(dsn='data/geospatial',layer='MP14_SUBZONE_WEB_PL')

    mpsz #this is to examine the content
    ```

2.  Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format

    ```{r}
    popdata <- read_csv("data/aspatial/respopagesex2011to2020.csv")
    ```

## Data Preparation

The data table should include variables:

-   YOUNG: age group 0 to 4 until age groyup 20 to 24,

-   ECONOMY ACTIVE: age group 25-29 until age group 60-64,

-   AGED: age group 65 and above,

-   TOTAL: all age group, and

-   DEPENDENCY: the ratio between young and aged against economy active group

## Data Wrangling

-   *pivot_wider()* of **tidyr** package, and

-   *mutate()*, *filter()*, *group_by()* and *select()* of **dplyr** package

note: `mutate()` creates new columns that are functions of existing variables. It can also modify (if the name is the same as an existing column) and delete columns (by setting their value to `NULL`).

```{r}
popdata2020 <- popdata %>%
  filter(Time == 2020) %>%
  group_by(PA, SZ, Age) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=Age,
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12]))%>%
  mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
           rowSums(.[13:15]))%>%
  mutate(`AGED`=rowSums(.[16:21]))%>%
  mutate(`TOTAL`=rowSums(.[3:21]))%>%
  mutate(`DEPENDENCY` = (`YOUNG`+`AGED`)/`ECONOMY ACTIVE`)%>%
  select(`PA`,`SZ`,`YOUNG`,`ECONOMY ACTIVE`,`AGED`,`TOTAL`,`DEPENDENCY`)

```

## Joining the attribute data and geospatial data

Further clean up of data, to convert PA and SZ field to uppercase, to be inline with SUBZONE_N and PLN_AREA_N where all are uppercase.

```{r}
popdata2020 <- popdata2020 %>%
  mutate_at(.vars = vars(PA, SZ),
            .funs = funs(toupper)) %>%
  filter(`ECONOMY ACTIVE`> 0)

```

Note mutate_at affects variables selected with a character vector or vars()

.vars

:   A list of columns generated by [`vars()`](https://dplyr.tidyverse.org/reference/vars.html), a character vector of column names, a numeric vector of column positions, or `NULL`.

.funs

:   A function `fun`, a quosure style lambda `~ fun(.)` or a list of either form.

Once cleaned, will be joining the geographical data and attribute table using planning subzone name e.g. *SUBZONE_N* and *SZ* as the common identifier. This is done using left_join() of dplyr.

Mutating joins add columns from `y` to `x`, matching observations based on the keys. There are four mutating joins: the inner join, and the three outer joins. `left_join()` keeps all observations in `x`.

```{r}
mpsz_pop2020 <- left_join(mpsz, popdata2020, by = c("SUBZONE_N" = "SZ"))
```

*left_join()* of **dplyr** package is used with `mpsz` simple feature data frame as the left data table is to ensure that the output will be a simple features data frame

```{r}
write_rds(mpsz_pop2020, "data/rds/mpszpop2020.rds")
```

Note: RDS (R Data Serialization) files are **a common format for saving R objects in RStudio** to preserve state of an object between R sessions therefore useful for sharing with others, replicating , or storing work done for later use.

## Choropleth Mapping Geospatial Data Using *tmap*

1.  **First approach : Plotting a thematic map quickly by using *qtm()*.**

    -   Easiest and quickest to draw a choropleth map

        -   *tmap_mode()* with \"plot\" option is used to produce a static map. For interactive mode, \"view\" option should be used.

        ```{=html}
        <!-- -->
        ```
        -   *fill* argument is used to map the attribute (i.e. DEPENDENCY)

        ```{r}
        tmap_mode("plot")
        qtm(mpsz_pop2020, 
            fill = "DEPENDENCY")
        ```

    -   the disadvantge of *qtm()* is that it makes aesthetics of
        individual layers harder to control. To draw a high quality cartographic choropleth map, **tmap**\'s drawing elements should be used.

2.  **Second approach: Plotting highly customizable thematic map by using tmap elements**

    ```{r}
    tm_shape(mpsz_pop2020)+
      tm_fill("DEPENDENCY", 
              style = "quantile", 
              palette = "Blues",
              title = "Dependency ratio") +
      tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone",
                main.title.position = "center",
                main.title.size = 1.2,
                legend.height = 0.45, 
                legend.width = 0.35,
                frame = TRUE) +
      tm_borders(alpha = 0.5) +
      tm_compass(type="8star", size = 2) +
      tm_scale_bar() +
      tm_grid(alpha =0.2) +
      tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
                 position = c("left", "bottom"))
    ```

Breaking down the tmap

1.  tm_shape() - used to define input data
2.  tm_polygons() - used to draw planning subzone polygons
    -   The default interval binning used to draw the choropleth map is called \"pretty\".

    -   The default colour scheme used is `YlOrRd` of ColorBrewer.

    -   By default, Missing value will be shaded in grey.

```{r}
tm_shape(mpsz_pop2020) + tm_polygons()
```

```{}
```

To draw a choropleth map showing the geographical distribution of selected variable by planning subzone, we just need to assign the target variable such as *Dependency* to *tm_polygons()*.

```{r}
tm_shape(mpsz_pop2020)+  tm_polygons("DEPENDENCY")

```

#### Drawing a choropleth map using *tm_fill()* and \*tm_border()\*\*

Note: *tm_polygons()* is a wraper of *tm_fill()* and *tm_border()*.

-   *tm_fill()* shades the polygons by using the default colour scheme

-   *tm_borders()* adds the borders of the shapefile onto the choropleth map.

Drawing a choropleth map by using *tm_fill()* alone.

```{r}
tm_shape(mpsz_pop2020)+ tm_fill("DEPENDENCY")
```

To add the boundary, use tm_borders

```{r}
tm_shape(mpsz_pop2020)+ tm_fill("DEPENDENCY") +   tm_borders(lwd = 0.1,  alpha = 1)
```

*alpha* argument : define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).

Other Arguments for tm_border():

-   *col* = border colour,

-   *lwd* = border line width. The default is 1,

-   *lty* = border line type. The default is \"solid\".

### Data classification methods of **tmap**

**tmap** provides a total ten data classification methods: *fixed*, *sd*, *equal*, *pretty* (default), *quantile*, *kmeans*, *hclust*, *bclust*, *fisher*, and *jenks*.

To define a data classification method, the *style* argument of *tm_fill()* or *tm_polygons()* will be used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "jenks") +
  tm_borders(alpha = 0.5)
```

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5)
```

*Own Note: Drawing choropleth maps using similar classification method but with different numbers of classes (i.e. 2, 6, 10, 20). The output maps shows that the higher number of classes, the more detailed or spread-out is the color on the map. It depends on how detailed we need the map to be, weather it is necessary to break down into so many numbers of classes for purpose of our analysis.*

#### Plotting choropleth map with custome break

```{r}
summary(mpsz_pop2020$DEPENDENCY)
```

With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90.

In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our *breaks* vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +
  tm_borders(alpha = 0.5)
```

### Colour Scheme

**tmap** supports colour ramps either defined by the user or a set of predefined colour ramps from the **RColorBrewer** package.

To change the colour, we assign the preferred colour to *palette* argument of *tm_fill()* :

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n = 6,
          style = "quantile",
          palette = "Blues") +
  tm_borders(alpha = 0.5)
```

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "-Greens") +
  tm_borders(alpha = 0.5) 
```

Note we can add "-" prefix to reverse the color shading.

### Map Layouts

-    combination of all map elements into a cohensive map

#### Map Legend

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "jenks", 
          palette = "Blues", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone \n(Jenks classification)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45, 
            legend.width = 0.35,
            legend.outside = FALSE,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)
```

#### Map style

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "-Greens") +
  tm_borders(alpha = 0.5) +
  tmap_style("classic")
```

#### Cartographic Furniture

To draw other map furniture such as compass, scale bar and grid lines, using tm_compass(), tm_scale_bar(), tm_grid():

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues",
          title = "No. of persons") +
  tm_layout(main.title = "Distribution of Dependency Ratio \nby planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar(width = 0.15) +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

TO RESET!

```{r}
tmap_style("white")
```

### Drawing Small Multiple Choropleth Maps

The facet maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.

In **tmap**, small multiple maps can be plotted in three ways:

1.  by assigning multiple values to at least one of the asthetic arguments (in this example using ***ncols*** in **tm_fill())**

    ```{r}
    tm_shape(mpsz_pop2020)+
      tm_fill(c("YOUNG", "AGED"),
              style = "equal", 
              palette = "Blues") +
      tm_layout(legend.position = c("right", "bottom")) +
      tm_borders(alpha = 0.5) +
      tmap_style("white")
    ```

    We can also use aesthetic arguments in each:

    ```{r}
    tm_shape(mpsz_pop2020)+ 
      tm_polygons(c("DEPENDENCY","AGED"),
              style = c("equal", "quantile"), 
              palette = list("Blues","Greens")) +
      tm_layout(legend.position = c("right", "bottom"))
    ```

2.  by defining a group-by variable in *tm_facets()*

    ```{r}
    tm_shape(mpsz_pop2020) +
      tm_fill("DEPENDENCY",
              style = "quantile",
              palette = "Blues",
              thres.poly = 0) + 
      tm_facets(by="REGION_N", 
                free.coords=TRUE, 
                drop.shapes=TRUE) +
      tm_layout(legend.show = FALSE,
                title.position = c("center", "center"), 
                title.size = 20) +
      tm_borders(alpha = 0.5)
    ```

3.  by creating multiple stand-alone maps with *tmap_arrange()*

    ```{r}
    youngmap <- tm_shape(mpsz_pop2020)+ 
      tm_polygons("YOUNG", 
                  style = "quantile", 
                  palette = "Blues")

    agedmap <- tm_shape(mpsz_pop2020)+ 
      tm_polygons("AGED", 
                  style = "quantile", 
                  palette = "Blues")

    tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
    ```

### Mappping Spatial Object Meeting a Selection Criterion

Can also use selection funtion to map spatial objects meeting the selection criterion, rather than having multiple small maps.

```{r}
tm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=="CENTRAL REGION", ])+
  tm_fill("DEPENDENCY", 
          style = "quantile", 
          palette = "Blues", 
          legend.hist = TRUE, 
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1) +
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45, 
            legend.width = 5.0,
            legend.position = c("right", "bottom"),
            frame = FALSE) +
  tm_borders(alpha = 0.5)
```
